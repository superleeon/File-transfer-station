1 对所有序列类型都适用的操作符(优先级从高到低, 不适用于复合类型的对象比较)

1.1 成员关系操作符: int, not in

1.2 连接操作符: +

1.3 重复操作符: *… sequence * int

1.4 切片操作符: (利用子序列方式结合三种操作方式, 可以非常灵活的控制序列)

1.4.1 [], 索引取值

1.4.2 [start : end], 索引范围取值

1.4.3 [::step], 切片的步长

1.4.4 切片操作符不会带来索引超出下标的异常

2 list.extend(iterable): 把另外一个序列追加到list中.

3 list.insert(index, object): 把一个元素object插入到list的index位置, 如果index是负数, 从后面向前数, 超过list下标后, 在末尾添加

4 类型转换

4.1 list(iter)  把可迭代对象转换为列表

4.2 str(obj)  把obj对象转换成字符串(对象的字符串表示法)

4.3 unicode(obj)  把对象转换成Unicode字符串(使用默认编码), 使用u”汉字”可以得到其unicode编码

4.4 basestring()  抽象工厂函数, 不能被实例化, 不能被调用, 仅作为str和unicode的父类

4.5 tuple(iter)  把一个可迭代对象转换成元组对象

4.6 enumerate(iterable)  生成由iterable每个元素的index值和item值组成的元组, 可以使用for key, value in enumerate的方式进行迭代

4.7 max(iterable, key=None) | max(arg0, arg1, …, key=None) 返回iterable或arg0…中的最大值, 如果要指定key, 必须是一个可以传递给sort()方法的回调函数…..要使用key, 必须使用key=method_name的方式传参, key指定的函数接收的参数是迭代的当前元素, 在该函数中, 对元素进行处理, 返回一个对象, python会根据返回对象比较大小, 得到该结果最大的元素对应的list中的元素

4.8 min同上面的max方法.  对于max和min方法, 如果是自定义类型, 又没有指定key, 那么默认是按照id(object)的结果计算的

4.9 reversed(sequence)  返回逆序访问的迭代器

4.10 sum(sequence, init=0)  返回sequence和可选参数init的总和, 等同于reduce(operator.add, sequence, init)

4.11 sorted(iterable, func=None, key=None, reverse=False)  接受一个可迭代对象, 返回一个有序列表, 可选参数func, key, reverse含义和list.sort相同

4.12 zip([item0, item1, …, itemn])  返回一个列表, [(item0, ), (item1, ), …, (itemn, )]

4.13 sort(cmp=None, key=None, reverse=False)  将序列进行排序, cmp指定一个接受两个参数的回调函数, 该函数得到的两个参数是序列中的两个元素, 比较将按照cmp指定的回调函数进行, 返回数字类型的比较结果, , , key指定一个接受一个参数的回调函数句柄, 该参数就是迭代到的元素, 在比较之前, 将会根据这个回调函数对要比较的元素进行一次处理, 实际参与比较的是经过该回调函数处理之后的返回值.  reverse指示是否对比较结果进行逆序

5 利用已有功能函数定义动态参数的函数: method = lambda x, y: cmp(x + 10, y - 10), 调用时还是使用句柄加参数的方式: method(x, y)

6 字符串: 如果先使用切片操作, 子串会被在内存中进行短时间的暂存, 可以通过id()得到值

7 比较: 普通字符串按照ascii值比较, Unicode字符串按照unicode值比较.

8 字符串切片, 下图是字符串切片的索引值, 如果开始或结束的索引值没有指定, 默认为0, 或-1. [::step]用于指定步长

 

9 成员操作符: in, not in, 可以判断一个子串是否在字符串中存在…使用find(), index(), rfind(), rindex()可以获得子串在源中的位置

10 string模块有一些预定义的字符串: ascii_letters, ascii_lowercase, ascii_uppercase, digits

11 循环的改善: 如果循环的终止条件是不变的(一般都是不变的), 那么尽量不在循环终止条件中调用方法是一个好的习惯, 在大量数据的情况下(5 * 10^8数据), 改善的循环效率提升了4秒左右, 平均计算得到改善后循环每次效率提升约为7.154 * 10^-8s 也就是71.54 ns

12 for-else方式的循环, else子句会在所有的元素都被循环完成之后执行, 如果break, 就不执行

13 join可以用来连接字符串, 这样的效率是更高的, 因为+连接必须为每个字符串创建内存

14 +连接字符串是运行时连接, “str1””str2”的方式则是编译时连接字符串

15 普通字符串和unicode字符串连接, 会把普通字符串转换成unicode字符串进行连接

16 %格式化字符串的参数:

16.1 %c  转换成字符(ascii值, 或长度为一的字符串)

16.2 %r  优先使用repr()函数进行字符串转换

16.3 %s  优先使用str()函数进行字符串转换

16.4 %d / %i  转成有符号的十进制数

16.5 %u  转成无符号的十进制数  遇到负号添加-号

16.6 %o  转成无符号八进制数  遇到负号添加-号

16.7 %x / %X  转成无符号十六进制数(x|X的大小写决定转换后得到十六进制数中的字母的大小写)   遇到负数, 则转换得到的结果中添加一个-号

16.8 %e / %E  转成科学计数法(e | E的大小写决定转换后得到的e的大小写)

16.9 %f / %F  转成浮点数(小数部分自然截断)

16.10 %%  输出%号

17 其他格式化操作符辅助指令(位于%和格式化标识的中间)

17.1 *  定义宽度或小数点精度"adfas%*dfasdf" % (5, 2.000000888)

17.2 –  用于左对齐    

17.3 +  在正数前加+号

17.4 (sp)  在正数前显示空格

17.5 #  在八进制前加0, 十六进制前显示0x或0X, 取决于用的是x或X    比如: "integer:%#X!" % 1984

17.6 (var)    映射变量(字典参数)

17.7 m.n   m是显示的最小总宽度, n是小数点后的位数

18 格式化字符串接收dict数据:”%(howmany)d days” % {“howmany”: 28}

19 字符串模板 s = Template(‘There are howmanyhowmany{lang} Quotation Symbols’)

19.1 s.substitute([key = value, key = value…])  这个函数必须提供所有的占位参数, 否则报错

19.2 s.safe_substitute([key = value, key = value…])  和substitute功能是一样的, 都是转成得到一个字符串, 但是这个方法对参数没有要求, 如果没有提供对应的参数, 就直接输出.

20 原始字符串操作符(r/R), 紧贴字符串左引号, 不区分大小写. 用来使字符串描述各自原始的意义, 而不使用转义

21 使用正则查找空白字符: m = re.search(r‘\\[rtfvn]’, r’Hello World!\n’)…

22 可以使用u | U ‘字符串’的方式创建unicode字符串, 该标识可以和r/R连用

23 python参数有位置参数和关键字参数两种, 位置参数在定义时只有参数名, 关键字参数定义时是key=value的形式

24 python也提供可变参, *为位置可变参, **为关键字可变参

25 如果使用* | **方式传递实参, * 可以将序列参数转变成每个元素作为单独参数, **则可以将dict转换成关键字参数

26 内建函数

26.1 cmp, 使用字符的ascii值进行比较(Unicode字符串按照unicode值比较)

26.2 max, min, len, enumerate, zip, 其中zip可以接受多个参数, 按照下面方式返回:

zip(“abcd”, “efg”, “hijk”, “lmn”) 返回: [('a', 'e', 'h', 'l'), ('b', 'f', 'i', 'm'), ('c', 'g', 'j', 'n')]

26.3 str和unicode都是basestring的特化类, 但是, Unicode又包含(类之间仅仅是兄弟关系, 元素范围上有包含关系)str的表示范围

26.4 chr(number), unichr(number), ord(string), chr和unichr分别用来把一个数字转换成一个对应类型的字符串, ord则是将一个string类型的单字符对象转换成为对应的ascii码或unicode编码

27 string模块的重要函数, 所有这些函数, 都可以省略第一个参数, 使用string.func的方式调用

27.1 string.index()和string.find()方法是一样的功能, 但是, index方法在查找不到字符串的时候, 会报一个异常, string.rfind(), string.rindex()用法相同, 是从右边开始查找

27.2 string.join(sequence[, str]) 如果只有一个参数, 返回一个将所有元素插空一个空格的字符串(如果是序列, 转换成为字符串), 如果有两个参数, 把第二个参数向第一个参数的每个空位进行插空

27.3 string.ljust(string, width[, fillchar])  填充fillchar(只能是一个字符)width个到string后面, 使string左对齐, 如果fillchar空, 填充空格, rjust为右对齐

27.4 string.lower(), string.upper(), string.swapcase()大小写转换

27.5 string.lstrip(), string.rstrip(), string.strip()  去除空格.

27.6 string.split(string, sub, count)  将string截取sub, 从左向右截取count个, 返回list

27.7 string.replace(string, old, new[, number=string.count(string, old)])  将string的old子串替换成new, 最多替换不超过number, number默认是old在string的数量

27.8 string.translate

27.9 string.zfill(string, width)  用width个0填充string的左面使其右对齐

28 unicode.encode(CODE_STRING) 按照指定编码方式编码字符串, decode反之, 按照指定编码方式解码

29 除了pickle模块之外, 其他模块都已经支持unicode..

30 UnicodeError异常在exceptions模块中定义, 是ValueError的子类, 所有关于Unicode编解码的异常都要继承自UnicodeError

31 与字符串类型有关的模块:

31.1 string: 字符串相关操作函数和工具, 比如Template类

31.2 re:  正则表达式

31.3 struct: 字符串和二进制之间的转换

31.4 c/StringIO  字符串缓冲对象, 操作方法类似于file对象

31.5 base64  Base16, 32, 64数据编解码

31.6 codecs   解码器注册和基类

31.7 crypt  进行单方面加密

31.8 difflib   找出序列间的不同

31.9 hashlib   多种不同安全哈希算法和信息摘要算法的API

31.10 hma    HMAC信息鉴权算法的python实现

31.11 md5  RSA的MD5信息摘要鉴权

31.12 rotor   提供多平台的加解密服务

31.13 sha    NIAT的安全哈希算法SHA

31.14 stringprep   提供用于IP协议的Unicode字符串

31.15 textwrap   文本打包和填充

31.16 unicodedata    Unicode数据库

32 字符串的关键点:

32.1 不可分字符类型

32.2 类似printf()的格式化字符串

32.3 三引号内可以接受特殊字符(What You See Is What You Get)

32.4 r | R原始字符串

32.5 python字符串不通过NUL或者\0结束

33 list的元素删除

33.1 del list[index]  根据index删除list中的元素

33.2 list.remove(value)   从list中移除值是value的第一个元素

33.3 list.pop()   类似栈的出栈操作, 弹出栈顶并返回

34 list的成员关系操作还是使用in | not in

35 列表解析: [var_name for var_name in list if expression]if之后和for之前都可以使用var_name进行运算

36 列表的比较操作, 隐式调用cmp方法, 比较规则是逐个扫描元素, 进行比较, 如果可以比较, 比较, 如果相等扫描下一个元素, 如果不相等返回结果, 如果两个元素类型不可以比较, 就比较两个对象的id()值.. 如果一直相等 ,直到一个列表扫描结束, 那么返回较长的列表较大

37 序列类型函数

37.1 len(), max(), min()

37.2 sorted() 和reversed()  返回的是被排序或逆序之后的序列, 不会改变序列本身的引用, 而序列自己的成员方法则会改变自身

37.3 enumerate()  返回一个key=>value方式的enumerate对象

37.4 zip()  将多个列表压缩成为一个元组列表…..zip返回的元组列表可以使用足够元组内元素数量的参数来迭代遍历每一个元素, 例如: for a, b, c, d in zip(alist, blist, clist, dlist)

37.5 使用list()和tuple()可以完成列表和元组之间的转换, 但是这种转换是值的转换, 所以他们是==的, 但是不是is的

37.6 extend(列表)方法接受另外一个列表追加到原列表之后

37.7 list.pop(index = -1)  list的pop可以弹出指定索引的值

38 处理一组对象的时候, 默认的是创建一个元组, 例如a = 1, 2, 3, 4 实际上是创建了一个元组(1, 2, 3, 4)

39 单独使用del删除一个元组元素是不可行的, 只能通过重组

40 元组的可变性: 元组的某一个元素指向了一个对象, 该对象是可变的, 那么改变该对象就相当于改变了元组的内容, 然而, 真正的我们的元组确实是没有改变的. It’s so wizardly. 为什么呢? 元组内部持有的是对方的引用, 那个对象无论怎么变都还是在那里, 所以, 元组内部的值(内存地址)是没有改变的.

41 函数可以返回多对象, 返回的实际也是一个元组

42 单元素元组使用括号创建时需要在后面显示的加上”, ”, 由于括号被重载作为一个分组操作符了, 在这里会优先使用分组功能, 所以, 返回的总是原始类型

43 相关模块:

43.1 数组array   受限的可变序列类型, 要求所有元素都是相同的类型

43.2 operator   包含函数调用形式的序列操作符, operator.concat(m, n)相当于m+n

43.3 re  perl风格的正则查找

43.4 StringIO / cStringIO  长字符串作为文件来操作, 比如read(),  seek()函数……c版本的速度更快一些

43.5 Textwrap  包裹/填充文本的函数

43.6 types   包含python支持的所有类型

43.7 collections  高性能容器数据类型

43.8 UserList  包含了list对象的完全的类实现, 允许用户获得类似list的类, 用以派生新的类和功能

44 浅拷贝: 拷贝原对象中的内容, 但是新创建对象. 比如一个list的浅拷贝就是把list中元素的引用值拷贝过去…  浅拷贝实例: 完全切片操作, 利用工厂函数, 使用copy模块的copy函数

45 深拷贝: 拷贝源对象中的内容, 如果某个属性(或序列中的元素)是可变对象, 把该可变对象的内容也进行拷贝

46 非容器类型对象没有拷贝一说

47 可变参: f(*args1, **args2), 如果关键字可变参不指定key值, 会被作为位置参数和前面的参数放到一个元组中….位置可变参在倒数第二个位置, 关键字可变参在倒数第一个位置.

48 map(function, iterable), 应用function在iterable的每一个元素, 返回值作为新的序列的元素